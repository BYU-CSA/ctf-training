https://tailcall.net/posts/cracking-rngs-lcgs/
  
Challenge 1: unknown increment
Ok, let’s move to the first challenge. What if we don’t know “increment”? i.e:
```
m = 81853448938945944
c = # unknown
n = 9223372036854775783
```
And let’s say that we know two consecutive values generated by this LCG:
```
s0 = 4501678582054734753
s1 = 4371244338968431602
```
Can we still attack this? Again, in this case, all values are 64bit, too much to bruteforce it. Let’s use some basic math instead.
 ```
s1 = s0*m + c   (mod n)
  
c  = s1 - s0*m  (mod n)
```
Easy. Now we can implement our attack in Python and plug concrete values in:
  ```
def crack_unknown_increment(states, modulus, multiplier):
    increment = (states[1] - states[0]*multiplier) % modulus
    return modulus, multiplier, increment
  
print crack_unknown_increment([4501678582054734753, 4371244338968431602], 9223372036854775783, 81853448938945944)
```
That’s it - challenge solved.

Challenge 2: unknown increment and multiplier
Previous two levels were rather trivial, time for something more interesting. Now we know neither multiplier nor increment:
```
m = # unknown
c = # unknown
n = 9223372036854775783
```
Now we don’t know increment and multiplier. At least we get to know three consecutive values from LCG:
```
s0 = 6473702802409947663
s1 = 6562621845583276653
s2 = 4483807506768649573
```
This looks much harder, but really isn’t - we still have two linear equations, and two unknowns, so everything should go smoothly:
```
s_1 = s0*m + c  (mod n)
s_2 = s1*m + c  (mod n)
  
s_2 - s_1 = s1*m - s0*m  (mod n)
s_2 - s_1 = m*(s1 - s0)  (mod n)
m = (s_2 - s_1)/(s_1 - s_0)  (mod n)
```
And when we know multiplier, problem is reduced to the one we already solved in chellenge 1. Let’s implement this in Python:
```
def crack_unknown_multiplier(states, modulus):
    multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus
    return crack_unknown_increment(states, modulus, multiplier)

print crack_unknown_multiplier([6473702802409947663, 6562621845583276653, 4483807506768649573], 9223372036854775783)
```
This algorithm uses modular division, so we’ll need modular inverse too. We can use this one.